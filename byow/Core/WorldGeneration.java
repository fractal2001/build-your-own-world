package byow.Core;

import byow.TileEngine.TERenderer;
import byow.TileEngine.TETile;
import byow.TileEngine.Tileset;

import java.io.*;
import java.util.*;

import edu.princeton.cs.algs4.WeightedQuickUnionUF;

import static java.lang.Math.*;

/**
 * Code to generate hallway tree based on a
 * variant of "tournament-bracket" style pathways
 */

public class WorldGeneration {

    private int width;
    private int height;
    private long seed;
    private boolean lightsOn = false;

    /**
     * Minimum and maximum length of hallways
     */
    private static final int MIN_LENGTH = 6;
    private static final int MAX_LENGTH = 9;
    private static final TETile[][] COLOR_SCHEMES = {
            {Tileset.SAKURA_AVATAR, Tileset.SAKURA_WALL, Tileset.SAKURA_FLOOR, Tileset.SAKURA_COIN},
            {Tileset.MINT_AVATAR, Tileset.MINT_WALL, Tileset.MINT_FLOOR, Tileset.MINT_COIN},
            {Tileset.SOLAR_AVATAR, Tileset.SOLAR_WALL, Tileset.SOLAR_FLOOR, Tileset.SOLAR_COIN},
            {Tileset.LAVENDER_AVATAR, Tileset.LAVENDER_WALL, Tileset.LAVENDER_FLOOR, Tileset.LAVENDER_COIN},
            {Tileset.NAVY_AVATAR, Tileset.NAVY_WALL, Tileset.NAVY_FLOOR, Tileset.NAVY_COIN},
            {Tileset.ACACIA_AVATAR, Tileset.ACACIA_WALL, Tileset.ACACIA_FLOOR, Tileset.ACACIA_COIN}
    };

    private static TETile HALLWAY_TILE = Tileset.FLOOR;
    private static TETile WALL = Tileset.WALL;
    private static TETile NOTHING = Tileset.NOTHING;
    private static TETile AVATAR = Tileset.AVATAR;
    private static TETile COIN = Tileset.COIN;
    private Coordinate[] directionsToCoords;
    private Random rand;
    private Random coinRand;
    private TETile[][] world;
    private WeightedQuickUnionUF connectedComponents;
    private ArrayList<Room> rooms;
    private Coordinate currentLocation;
    private int coinCount;
    private int randCoinCount;
    private int theme;

    private final int MAXDEPTH = 6;

    private class Coordinate {
        private int x;
        private int y;
        public Coordinate(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public Coordinate add(Coordinate P) {
            return new Coordinate(x + P.x, y + P.y);
        }

        public Coordinate mul(int i) {
            return new Coordinate(x*i, y*i);
        }
        public boolean isValid() {
            return (0 <= x && x < width && 0 <= y && y < height);
        }

        @Override
        public String toString() {
            return "(" + x + ", " + y + ')';
        }
    }

    private class Room {
        private Coordinate bottomLeft;
        private Coordinate topRight;
        public Room(Coordinate bottomLeft, Coordinate topRight) {
            this.bottomLeft = bottomLeft;
            this.topRight = topRight;
        }
    }

    /**
     * Modifies a 2-dimensional array of TETiles by adding
     * hallways randomly generated by seed. Replaces certain
     * tiles in world by HALLWAY_TILE
     *
     * @param seed the seed to use for world generation
     */
    public WorldGeneration(long seed, int width, int height, int colorScheme) {
        //intialize variables ig
        this.width = width;
        this.height = height;
        world = new TETile[width][height];
        //initialize world array
        for (int x = 0; x < width; x += 1) {
            for (int y = 0; y < height; y += 1) {
                world[x][y] = NOTHING;
            }
        }

        this.seed = seed;
        rand = new Random(seed);
        coinRand = new Random(RandomUtils.uniform(rand, Long.MAX_VALUE));
        theme = RandomUtils.uniform(rand, 6);
        setColorScheme(theme);
        if (colorScheme != 0) {
            setColorScheme(colorScheme - 1);
            theme = colorScheme - 1;
        }
        rooms = new ArrayList<>();
        directionsToCoords = new Coordinate[4];
        directionsToCoords[0] = new Coordinate(1,0);
        directionsToCoords[1] = new Coordinate(0,1);
        directionsToCoords[2] = new Coordinate(-1,0);
        directionsToCoords[3] = new Coordinate(0,-1);
        coinCount = 0;
        /**
         *     1
         *  2     0
         *     3
         */


        int numRooms = 0;
        for (int i = 0; i < 30; i++){
            int x = RandomUtils.uniform(rand, 1, width-1);
            int y = RandomUtils.uniform(rand, 1, height-1);
            int xLen = generateLength();
            int yLen = generateLength();
            Coordinate start = new Coordinate(x, y);
            Coordinate end = new Coordinate(x+ xLen, y+ yLen);
            // EXPIRIMENTAL
            // ESSENTIALLY MAKING BOXES SMALLER BY ONE COORDINATE TO MAKE SURE THE PADDING DOESNT OVERLAP
            // MAKES THE WORLD LOOK BETTER?
            Coordinate diffBot = new Coordinate(1,1);
            Coordinate diffTop = new Coordinate(-1,-1);

            if (end.add(new Coordinate(1,1)).isValid() && checkAll(start, end, NOTHING)) {
                drawBox(start, end, HALLWAY_TILE);
                //drawBox(start.add(diffBot), end.add(diffTop), HALLWAY_TILE);
                //addPadding(start, end, Tileset.WALL);
                //rooms.add(new Room(start, end));
                rooms.add(new Room(start.add(diffBot), end.add(diffTop)));
                numRooms += 1;

            }
        }
        connectedComponents = new WeightedQuickUnionUF(numRooms);

        // Now generate hallways by randomly connecting two rooms:
        while (connectedComponents.count() != 1) {
            int x = RandomUtils.uniform(rand, numRooms);
            int y = RandomUtils.uniform(rand, numRooms);
            if (!connectedComponents.connected(x,y)) {
                connectedComponents.union(x,y);
                connectRooms(rooms.get(x), rooms.get(y));
            }
        }
        addWalls(WALL);

        // Pick a spawn point for the main character
        Room spawnRoom = rooms.get(RandomUtils.uniform(rand, numRooms));
        Coordinate sum = spawnRoom.bottomLeft.add(spawnRoom.topRight);
        world[sum.x / 2][sum.y / 2] = AVATAR;

        // To track the character moving
        currentLocation = new Coordinate(sum.x / 2, sum.y / 2);
        generateCoin();
    }

    public WorldGeneration(int width, int height) {
        this((int) (100000 *Math.random()), width, height, 0);
    }

    public void connectRooms(Room start, Room end) {
        Coordinate randomStart = randomRoomAnchor(start);
        Coordinate randomEnd = randomRoomAnchor(end);
        int x = RandomUtils.uniform(rand, 2);
        drawSegment(randomStart, randomEnd, 0);
    }

    /**
     * Returns a random coordinate on the boundary of given room.
     * @param room Room object from which to choose the anchor
     * @return random Coordinate on the boundary of room
     */
    public Coordinate randomRoomAnchor(Room room) {
        Coordinate bottomLeft = room.bottomLeft;
        Coordinate topRight = room.topRight;
        int randomX = RandomUtils.uniform(rand, bottomLeft.x, topRight.x + 1);
        int randomY = RandomUtils.uniform(rand, bottomLeft.y, topRight.y + 1);
        return new Coordinate(randomX, randomY);
    }

    public void drawHorizontalSegment(Coordinate start, Coordinate end) {
        // ASSUMES SAME Y-COORDINATE
        int startX = min(start.x, end.x);
        int endX = max(start.x, end.x);
        for (int j = startX; j <= endX && j < width; j += 1) {
            world[j][start.y] = HALLWAY_TILE;
        }
    }

    public void drawVerticalSegment(Coordinate start, Coordinate end) {
        // ASSUMES SAME X-COORDINATE
        int startY = min(start.y, end.y);
        int endY = max(start.y, end.y);
        for (int j = startY; j <= endY && j < width; j += 1) {
            world[start.x][j] = HALLWAY_TILE;
        }
    }

    public void drawSegment(Coordinate start, Coordinate end, int orientation) {
        // Let start = (xs, ys) and end = (xe, ye).
        // orientation represents if the first move is horizontal or vertical
        // if orientation = 0, it connects (xs,ys) -- (xe,ys) -- (xe, ye) (horizontal first)
        // else it connects (xs, ys) -- (xs, ye) -- (xe, ye) (vertical first)
        Coordinate anchor;
        if (orientation == 0) {
            anchor = new Coordinate(end.x, start.y);
            drawHorizontalSegment(start, anchor);
            drawVerticalSegment(anchor, end);
        } else {
            anchor = new Coordinate(start.x, end.y);
            drawVerticalSegment(start, anchor);
            drawHorizontalSegment(anchor, end);
        }

    }


    private int generateLength() {
        return RandomUtils.uniform(rand, MIN_LENGTH, MAX_LENGTH + 1);
    }


    // start x, y must be less than end x,y
    private int drawBox(Coordinate start, Coordinate end, TETile tile) {
        for(int i = start.x; i < end.x; i++) {
            for (int j = start.y; j < end.y; j++) {
                world[i][j] = tile;
            }
        }
        return 0;
    }

    //DEPRECATED
    private int addPadding(Coordinate start, Coordinate end, TETile tile) {
        for(int i = start.x-1; i < end.x+1; i++) {
            world[i][start.y-1] = tile;
            world[i][end.y] = tile;
        }
        for(int j = start.y-1; j < end.y+1; j++) {
            world[start.x-1][j] = tile;
            world[end.x][j] = tile;
        }
        return 0;
    }
    private boolean checkAll(Coordinate start, Coordinate end, TETile tile) {
        for(int i = start.x; i < end.x && i < width; i++) {
            for (int j = start.y; j < end.y && j < height; j++) {
                if(world[i][j] != tile) {
                    return false;
                }
            }
        }
        return true;
    }

    public void addWalls(TETile tile) {
        for (int i = 0; i < width; i += 1) {
            for (int j = 0; j < height; j += 1) {
                if (world[i][j] == HALLWAY_TILE) {
                    int[] rx = {0, 0, 1, -1, 1, 1, -1, -1};
                    int[] ry = {1, -1, 0, 0, -1, 1, -1, 1};
                    for (int k = 0; k < 8; k += 1) {
                        int x = i + rx[k];
                        int y = j + ry[k];
                        Coordinate P = new Coordinate(x,y);
                        if (P.isValid() && world[x][y] != HALLWAY_TILE) {
                            world[x][y] = tile;
                        }
                    }
                }
            }
        }
    }

    /**
     * Sets the color scheme to be used for the world
     * based on the integer scheme.
     * @param scheme a number from 0 to 6,
     * 0 : sakura
     * 1 : mint
     * 2 : solar
     * 3 : lavender
     * 4 : navy
     * 5 : acacia
     */
    public void setColorScheme(int scheme) {
        this.AVATAR = COLOR_SCHEMES[scheme][0];
        this.WALL = COLOR_SCHEMES[scheme][1];
        this.HALLWAY_TILE = COLOR_SCHEMES[scheme][2];
        this.COIN = COLOR_SCHEMES[scheme][3];
    }


    //    private boolean checkConflict (Coordinate start, Coordinate end) {
//        for(int i = start.x; i < end.x; i++) {
//            for (int j = start.y; j < end.y; j++) {
//                if(world[i][j] != Tileset.NOTHING) {
//                    return true;
//                }
//            }
//        }
//        return false;
//    }
    public TETile[][] getWorld(){
        if (lightsOn) {
            return world;
        }
        else {
            return getWNoLights();
        }
    }
    public TETile[][] getWNoLights(){
        int[][] ar = new int[width][height];
        for(int i = 0; i < width; i++){
            for(int j = 0; j < height; j++) {
                ar[i][j] = -1;
            }
        }
        ar[currentLocation.x][currentLocation.y]= 0;

        Queue<Coordinate> q = new ArrayDeque<>();
        q.add(currentLocation);
        while(!q.isEmpty()) {
            Coordinate c = q.remove();
            for (int i = 0 ; i< 4; i++){
                Coordinate out =c.add(directionsToCoords[i]);
                if(out.isValid() && ar[out.x][out.y] < 0) {
                    ar[out.x][out.y] = ar[c.x][c.y] +1;
                    if(world[out.x][out.y] == HALLWAY_TILE || world[out.x][out.y] == COIN ) {
                        q.add(out);
                    }
                }
            }
        }
        TETile[][] outAr = new TETile[width][height];
        for(int i = 0; i < width; i++){
            for(int j = 0; j < height; j++) {
                if(ar[i][j] >=0 && ar[i][j] < MAXDEPTH){
                    outAr[i][j] = world[i][j];
                }
                else {
                    outAr[i][j] = NOTHING;
                }

                if(world[i][j] == COIN){
                    outAr[i][j] = COIN;
                }
            }
        }
        return outAr;

    }

    // for debugging

//    private void printW(){
//        int[][] ar = new int[width][height];
//        for(int i = 0; i < width; i++) {
//            for (int j = 0; j < height; j++) {
//                if(world[i][j] == Tileset.NOTHING) {
//                    ar[i][j] = 0;
//                } else if (world[i][j] == HALLWAY_TILE) {
//                    ar[i][j] =1;
//                }
//            }
//        }
//        for(int i = 0; i < width; i++) {
//            System.out.println(Arrays.toString(ar[i]));
//        }
//    }

    /**
     * Moves the avatar in the direction dir by deleting the
     * tile containing the character and moving the avatar one step
     * in the desired direction. Does not move character if character
     * is at the edge of the map.
     * @param dir a number representing the direction the avatar wants to move
     */
    public void moveCharacter(int dir) {
        /**
         *     1
         *  2     0
         *     3
         */
        Coordinate vec = directionsToCoords[dir];
        if (currentLocation.add(vec).isValid()) {
            Coordinate newLocation = currentLocation.add(vec);
            if (world[newLocation.x][newLocation.y] == HALLWAY_TILE) {
                world[currentLocation.x][currentLocation.y] = HALLWAY_TILE;
                world[newLocation.x][newLocation.y] = AVATAR;
                currentLocation = newLocation;
            } else if (world[newLocation.x][newLocation.y] == COIN) {
                world[currentLocation.x][currentLocation.y] = HALLWAY_TILE;
                world[newLocation.x][newLocation.y] = AVATAR;
                currentLocation = newLocation;
                generateCoin();
                coinCount++;
            }
        }
    }

    private void generateCoin() {
        int x,y;
        while(true){
            x = RandomUtils.uniform(coinRand, width);
            y = RandomUtils.uniform(coinRand, height);
            randCoinCount+=2;
            if(world[x][y] == HALLWAY_TILE) break;
        }
        world[x][y] = COIN;
    }

    public int getCoinCount(){
        return coinCount;
    }

    //Save and load format
    //Seed
    //coinCount
    //RandCoinCount
    //Theme
    //LightsOn
    //TET Array
    public void save() throws IOException {
        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("saveFile.txt")));
        out.println(seed);
        out.println(coinCount);
        out.println(randCoinCount);
        out.println(theme);
        if(lightsOn){
            out.println("1");
        }
        else {
            out.println("0");
        }
        out.println(TETile.toString(world));
//        for(int i = 0; i < world.length; i++) {
//            out.println(Arrays.toString(world[i]));
//        }
        out.close();
    }


    // Rand Coint count is how many times we called rand coin
    public void load() throws IOException {
        BufferedReader f = new BufferedReader(new FileReader("saveFile.txt"));

        seed = Long.parseLong(f.readLine());
        rand = new Random(seed);
        coinRand = new Random(RandomUtils.uniform(rand, Long.MAX_VALUE));
        coinCount = Integer.parseInt(f.readLine());
        randCoinCount = Integer.parseInt(f.readLine());
        for(int i = 0; i < randCoinCount; i++){
            RandomUtils.uniform(coinRand, width);
        }
        theme = Integer.parseInt(f.readLine());
        setColorScheme(theme);
        if(Integer.parseInt(f.readLine()) == 1){
            lightsOn = true;
        }
        else{
            lightsOn = false;
        }
        world = new TETile[width][height];
        for(int i = 0; i < height; i++) {
            char[] ar = f.readLine().toCharArray();

            for(int j= 0; j < width; j++) {
                switch (ar[j]) {
                    case ' ':
                        world[j][height - i-1] = NOTHING;
                        break;
                    case '#':
                        world[j][height - i-1] = WALL;
                        break;
                    case '·':
                        world[j][height - i-1] = HALLWAY_TILE;
                        break;
                    case 'ツ':
                        world[j][height - i-1] = AVATAR;
                        currentLocation = new Coordinate(j, height - i-1);
                        break;
                    case '$':
                        world[j][height - i-1] = COIN;
                        break;
                }
            }
        }
    }
    public void changeLights() {
        lightsOn = !lightsOn;
    }

}
